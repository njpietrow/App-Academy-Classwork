<section class="sc-brqgnP gYSzuT sc-bJHhxl dHctkM"><h1>Memory Puzzle</h1><p>Today we're going to implement a simple command-line version of the classic
<a href="http://mypuzzle.org/find-the-pair" target="_blank">Match 2 memory card game</a>.</p><p>Here is a glimpse of what the final product will look like when you are done:</p><p><img src="https://assets.aaonline.io/fullstack/ruby/projects/memory/memory.gif" alt="memory-gif"></p><h2>Learning Goals</h2><ul><li>Understand how classes interact in an object-oriented program</li><li>Be able to use <code class="sc-cMljjf hbDMZX">require_relative</code></li><li>Be able to write the methods <code class="sc-cMljjf hbDMZX">[]</code> and <code class="sc-cMljjf hbDMZX">[]=</code> and explain how they work</li><li>Develop a workflow that uses pry to test small parts of your code</li><li>Know how to initialize an Array with a default value</li><li>Know how to use duck typing to allow different classes to interact with your
program</li></ul><p>Write classes for Card, Board, and Game. Please put each class in its own file
and use <code class="sc-cMljjf hbDMZX">require_relative</code> to include other files in your program.</p><h2>Card</h2><p>A Card has two useful bits of information: its face value, and whether it is
face-up or face-down. You'll want instance variables to keep track of this
information. You'll also want a method to display information about the card:
nothing when face-down, or its value when face-up. I also wrote <code class="sc-cMljjf hbDMZX">#hide</code>,
<code class="sc-cMljjf hbDMZX">#reveal</code>, <code class="sc-cMljjf hbDMZX">#to_s</code>, and <code class="sc-cMljjf hbDMZX">#==</code> methods.</p><p>Common problem: Having issues with <code class="sc-cMljjf hbDMZX">#hide</code> and <code class="sc-cMljjf hbDMZX">#reveal</code>? Review the 
Testing Small (from Memory Puzzle) reading in the sidebar.</p><h2>Board</h2><p>The Board is responsible for keeping track of all your Cards. You'll want a grid
instance variable to contain Cards. Useful methods:</p><ul><li><code class="sc-cMljjf hbDMZX">#populate</code> should fill the board with a set of shuffled Card pairs</li><li><code class="sc-cMljjf hbDMZX">#render</code> should print out a representation of the Board's current state</li><li><code class="sc-cMljjf hbDMZX">#won?</code> should return true if all cards have been revealed.</li><li><code class="sc-cMljjf hbDMZX">#reveal</code> should reveal a Card at <code class="sc-cMljjf hbDMZX">guessed_pos</code> (unless it's already face-up,
in which case the method should do nothing). It should also return the value
of the card it revealed (you'll see why later).</li></ul><h3>Parallel Assignment</h3><p>In Ruby you can declare and assign multiple variables at once using commas to
separate multiple variables and values. For example,</p><pre style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"><code style="color: rgb(248, 248, 242); background: none; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; font-size: 16px;">x<span class="token" style="color: rgb(248, 248, 242);">,</span> y<span class="token" style="color: rgb(248, 248, 242);">,</span> z <span class="token" style="color: rgb(248, 248, 242);">=</span> <span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">2</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">3</span> <span class="token" style="color: rgb(119, 128, 144);"># x = 1, y = 2, z = 3</span></code></pre><p>And if there's not the same number of variables and values?</p><pre style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"><code style="color: rgb(248, 248, 242); background: none; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; font-size: 16px;">x<span class="token" style="color: rgb(248, 248, 242);">,</span> y <span class="token" style="color: rgb(248, 248, 242);">=</span> <span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">2</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">3</span> <span class="token" style="color: rgb(119, 128, 144);"># x = 1, y = 2, 3 is not assigned</span>
a<span class="token" style="color: rgb(248, 248, 242);">,</span> b<span class="token" style="color: rgb(248, 248, 242);">,</span> c <span class="token" style="color: rgb(248, 248, 242);">=</span> <span class="token" style="color: rgb(174, 129, 255);">10</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">20</span> <span class="token" style="color: rgb(119, 128, 144);"># a = 10, b = 20, c = nil</span></code></pre><p>When there are multiple variables assigned to an array, Ruby expands the array
so that each element becomes its own value! For example,</p><pre style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"><code style="color: rgb(248, 248, 242); background: none; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; font-size: 16px;">x<span class="token" style="color: rgb(248, 248, 242);">,</span> y<span class="token" style="color: rgb(248, 248, 242);">,</span> z <span class="token" style="color: rgb(248, 248, 242);">=</span> <span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">2</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">3</span><span class="token" style="color: rgb(248, 248, 242);">]</span> <span class="token" style="color: rgb(119, 128, 144);"># x = 1, y = 2, z = 3</span>
a<span class="token" style="color: rgb(248, 248, 242);">,</span> b<span class="token" style="color: rgb(248, 248, 242);">,</span> c <span class="token" style="color: rgb(248, 248, 242);">=</span> <span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">10</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">20</span><span class="token" style="color: rgb(248, 248, 242);">]</span> <span class="token" style="color: rgb(119, 128, 144);"># a = 10, b = 20, c = nil</span></code></pre><p>This is very helpful to use when writing <code class="sc-cMljjf hbDMZX">[](pos)</code> and <code class="sc-cMljjf hbDMZX">[]=(pos, value)</code> for
your Board to access <code class="sc-cMljjf hbDMZX">row</code> and <code class="sc-cMljjf hbDMZX">col</code>. Because the <code class="sc-cMljjf hbDMZX">pos</code> exists as an array, it's
better to pass it as an array in a method call, relying on the method to index
the array.</p><h2>Game</h2><p>The Game should have instance variable for the Board and the previously-guessed
position (if any). It should also have methods for managing the Board-Player
interaction. You may want a <code class="sc-cMljjf hbDMZX">play</code> loop that runs until the game is <code class="sc-cMljjf hbDMZX">over</code>.
Inside the loop, you should <code class="sc-cMljjf hbDMZX">render</code> the board, <code class="sc-cMljjf hbDMZX">prompt</code> the player for input,
and get a guessed <code class="sc-cMljjf hbDMZX">pos</code>. Pass this <code class="sc-cMljjf hbDMZX">pos</code> to a <code class="sc-cMljjf hbDMZX">make_guess</code> method, where you
will handle the actual memory/matching logic. Some tips on implementing this:</p><ul><li>If we're not already checking another Card, leave the card at <code class="sc-cMljjf hbDMZX">guessed_pos</code>
face-up and update the <code class="sc-cMljjf hbDMZX">previous_guess</code> variable.</li><li>If we <strong>are</strong> checking another card, we should compare the Card at
<code class="sc-cMljjf hbDMZX">guessed_pos</code> with the one at <code class="sc-cMljjf hbDMZX">previous_guess</code>.<ul><li>If the cards match, we should leave them both face-up.</li><li>Else, flip both cards face-down.</li><li>In either case, reset <code class="sc-cMljjf hbDMZX">previous_guess</code>.</li></ul></li></ul><p>It wouldn't be an interesting game if the player could see their previous moves.
Run <code class="sc-cMljjf hbDMZX">system("clear")</code> before <code class="sc-cMljjf hbDMZX">render</code>ing the Board. This will hide any previous
output from the player. <code class="sc-cMljjf hbDMZX">sleep(n)</code> will pause the program for <code class="sc-cMljjf hbDMZX">n</code> seconds. Use
this method to (temporarily) show the player an incorrect guess before flipping
the Cards face-down again.</p><h2>AI</h2><h3>Refactor game to include a HumanPlayer class</h3><p>Before actually implementing the computer player, let's make things easier on
ourselves and refactor the game to accept player classes. In order to accomplish
this, move all of your user input logic into the player class. I moved the
following methods out of the Game class into the player:</p><ul><li><code class="sc-cMljjf hbDMZX">prompt</code></li><li><code class="sc-cMljjf hbDMZX">get_input</code></li></ul><p>Before moving on, make sure your game runs successfully with a <code class="sc-cMljjf hbDMZX">HumanPlayer</code>.</p><h3>Create a ComputerPlayer class</h3><p>The computer player's strategy should be as follows:</p><ul><li>On its first guess, if it knows where 2 matching cards are, guess one of them,
otherwise guess randomly among cards it has not yet seen.</li><li>On its second guess, if its first guess revealed a card whose value matches a
known location, guess that location, otherwise guess randomly among cards it
has not yet seen.</li></ul><p>Now comes the tricky part. With the HumanPlayer, we didn't need to explicitly
receive the data from the card we're flipping over; we just read it off the
terminal output. The computer won't be quite so savvy. Let's write some methods
to have it accept the revealed card information from the game:</p><ul><li><code class="sc-cMljjf hbDMZX">receive_revealed_card</code> should take in a position and the value of the card
revealed at that location. It should then store it in a <code class="sc-cMljjf hbDMZX">@known_cards</code> hash.</li><li><code class="sc-cMljjf hbDMZX">receive_match</code> should take in two positions which are a successful match. I
stored these in an instance variable <code class="sc-cMljjf hbDMZX">@matched_cards</code></li></ul><p>The game should then call these methods on the player in addition to displaying
the revealed cards to the terminal.</p><p><strong>NB:</strong> The game shouldn't have to know whether a human or computer is playing.
Instead, it should use <em>duck typing</em>. (See today's reading on Duck Typing.) This
may involve writing some "dummy" methods on the <code class="sc-cMljjf hbDMZX">HumanPlayer</code> class. That's ok.</p><h2>Bonus</h2><p><strong>Come back to this after you finish Sudoku!</strong></p><ul><li>Implement a simple command-line interface, allowing the user to determine the
difficulty of the game (i.e., the size of the board). Do this <strong>before</strong> the
Game is <code class="sc-cMljjf hbDMZX">initialize</code>d. Remember <code class="sc-cMljjf hbDMZX">if __FILE__ == $PROGRAM_NAME</code>!</li><li>Enforce an upper limit on the number of turns played. If the limit is
exceeded, the player loses.</li><li>Let's add a twist: start the game by placing a certain number of "bombs"
instead of normal cards. When the game starts, show the bombs for 5 seconds or
so; then hide them. If the player reveals a bomb, the game ends. (If you feel
this is too harsh, perhaps you can implement "lives" or "hit points"). You
might also want to determine the bomb count as a function of board size.</li><li>We've already got a working "Match 2" puzzle. What about a "Match 3" or "Match
4"? Generalize your code to work for any number of matching cards.</li></ul></section>
