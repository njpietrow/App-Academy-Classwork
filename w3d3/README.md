<section class="sc-brqgnP gYSzuT sc-bJHhxl dHctkM"><h1>Recursion</h1><h2>Learning Goals</h2><ul><li>Know how to reason about recursive programs<ul><li>Be able to write a base case for a recursive method</li><li>Be able to write the inductive step for a recursive method</li></ul></li><li>Be able to explain the benefits of writing a method recursively vs.
iteratively</li><li>Be able to trace a recursive method and figure out how many recursive steps it
will take</li><li>Know how to write recursive sorting and searching algorithms</li></ul><h3>Warmup</h3><ul><li>Write a recursive method, <code class="sc-cMljjf hbDMZX">range</code>, that takes a start and an end and returns
an array of all numbers in that range, exclusive. For example, <code class="sc-cMljjf hbDMZX">range(1, 5)</code>
should return <code class="sc-cMljjf hbDMZX">[1, 2, 3, 4]</code>. If <code class="sc-cMljjf hbDMZX">end &lt; start</code>, you can return an empty array.</li><li>Write both a recursive and iterative version of sum of an array.</li></ul><h3>Exponentiation</h3><p>Write two versions of exponent that use two different recursions:</p><pre style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"><code style="color: rgb(248, 248, 242); background: none; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; font-size: 16px;"># this is math, not Ruby methods.

# recursion 1
exp(b, 0) = 1
exp(b, n) = b * exp(b, n - 1)

# recursion 2
exp(b, 0) = 1
exp(b, 1) = b
exp(b, n) = exp(b, n / 2) ** 2             [for even n]
exp(b, n) = b * (exp(b, (n - 1) / 2) ** 2) [for odd n]</code></pre><p>Note that for recursion 2, you will need to square the results of
<code class="sc-cMljjf hbDMZX">exp(b, n / 2)</code> and <code class="sc-cMljjf hbDMZX">(exp(b, (n - 1) / 2)</code>. Remember that you don't need to do
anything special to square a number, just calculate the value and multiply it by
itself. <strong>So don't cheat and use exponentiation in your solution</strong>.</p><p><strong>Suggestion</strong>: Break the methods down into parts. For more information check 
out the Breaking Methods Into Parts reading in the sidebar.</p><p><strong>Suggestion 2</strong>: Try walking through your code with <strong>Simple Examples</strong>.</p><p>If the <code class="sc-cMljjf hbDMZX">n == 256</code>, about how many nested recursive steps will we run in the
first case?</p><p>How deep will we need to recurse for the second? Keep in mind that the first
reduces the exponent by one for each recursion, while the second reduces it by
half.</p><p>In addition to testing your methods by running the code, try the following
exercise:</p><p>On paper, write out the value of each variable for every line in the code:</p><ul><li>Write out what happens with base 0 and power 0 as inputs (should be easy).
e.g., if you had run <code class="sc-cMljjf hbDMZX">exp(0,0)</code>.</li><li>Write out what happens for base 0 and power 1. e.g., if you had run
<code class="sc-cMljjf hbDMZX">exp(0,1)</code>.</li><li>Write out what happens for base 1 and power 0.</li><li>Write out what happens for base 1 and power 1.</li><li>Write out what happens for base 1 and power 2.</li><li>Write out what happens for base 2 and power 0.</li><li>Write out what happens for base 2 and power 1.</li><li>Write out what happens for base 2 and power 2.</li></ul><p>Make sure you can trace from the very beginning to the very end in these
examples.</p><p>How many examples do you need to walk through to be confident that it works?</p><h3>Deep dup</h3><p>The <code class="sc-cMljjf hbDMZX">#dup</code> method doesn't make a <strong>deep copy</strong>:</p><pre style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"><code style="color: rgb(248, 248, 242); background: none; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; font-size: 16px;">robot_parts <span class="token" style="color: rgb(248, 248, 242);">=</span> <span class="token" style="color: rgb(248, 248, 242);">[</span>
  <span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(230, 219, 116);">"nuts"</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(230, 219, 116);">"bolts"</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(230, 219, 116);">"washers"</span><span class="token" style="color: rgb(248, 248, 242);">]</span><span class="token" style="color: rgb(248, 248, 242);">,</span>
  <span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(230, 219, 116);">"capacitors"</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(230, 219, 116);">"resistors"</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(230, 219, 116);">"inductors"</span><span class="token" style="color: rgb(248, 248, 242);">]</span>
<span class="token" style="color: rgb(248, 248, 242);">]</span>

robot_parts_copy <span class="token" style="color: rgb(248, 248, 242);">=</span> robot_parts<span class="token" style="color: rgb(248, 248, 242);">.</span>dup

<span class="token" style="color: rgb(119, 128, 144);"># shouldn't modify robot_parts</span>
robot_parts_copy<span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">]</span> <span class="token" style="color: rgb(248, 248, 242);">&lt;</span><span class="token" style="color: rgb(248, 248, 242);">&lt;</span> <span class="token" style="color: rgb(230, 219, 116);">"LEDs"</span>
<span class="token" style="color: rgb(119, 128, 144);"># but it does</span>
robot_parts<span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">]</span> <span class="token" style="color: rgb(119, 128, 144);"># =&gt; ["capacitors", "resistors", "inductors", "LEDs"]</span></code></pre><p>When we <code class="sc-cMljjf hbDMZX">dup</code> an <code class="sc-cMljjf hbDMZX">Array</code>, it creates a new array to hold the elements, but
doesn't recursively <code class="sc-cMljjf hbDMZX">dup</code> any arrays contained therein. So the <code class="sc-cMljjf hbDMZX">dup</code> method
creates one new array, but just copies over references to the original interior
arrays.</p><p>Sometimes you want a shallow dup and sometimes you want a deep dup. Ruby keeps
things simple by giving you shallow dup, and letting you write deep dup
yourself.</p><p><strong>Using recursion and the <code class="sc-cMljjf hbDMZX">is_a?</code> method, write an <code class="sc-cMljjf hbDMZX">Array#deep_dup</code> method that
will perform a "deep" duplication of the interior arrays.</strong></p><p><strong>Note:</strong> For simplicity's sake, we are only going to ensure the deep
duplication of arrays. Don't worry about deep-duping (or regular-duping) other
types of mutable objects (like strings, hashes, instances of custom classes,
etc.), since this would require that we implement a deep dup method for each of
those classes, as well.</p><p>It's okay to iterate over array elements using the normal <code class="sc-cMljjf hbDMZX">each</code> for this one
:-)</p><p><strong>You should be able to handle "mixed" arrays</strong>. For instance:
<code class="sc-cMljjf hbDMZX">[1, [2], [3, [4]]]</code>.</p><h3>Fibonacci</h3><p>Write a recursive and an iterative Fibonacci method. The method should take in
an integer <code class="sc-cMljjf hbDMZX">n</code> and return the first <code class="sc-cMljjf hbDMZX">n</code> Fibonacci numbers <strong>in an array</strong>.</p><p>You shouldn't have to pass any arrays between methods; you should be able to do
this just passing a single argument for the number of Fibonacci numbers
requested.</p><h3>Binary Search</h3><p>The binary search algorithm begins by comparing the target value to the value of
the middle element of the sorted array. If the target value is equal to the
middle element's value, then the position is returned and the search is
finished. If the target value is less than the middle element's value, then the
search continues on the lower half of the array; or if the target value is
greater than the middle element's value, then the search continues on the upper
half of the array. This process continues, eliminating half of the elements, and
comparing the target value to the value of the middle element of the remaining
elements - until the target value is either found (and its associated element
position is returned), or until the entire array has been searched (and "not
found" is returned).</p><p>Write a recursive <a href="http://en.wikipedia.org/wiki/Binary_search" target="_blank">binary search</a>: <code class="sc-cMljjf hbDMZX">bsearch(array, target)</code>.
<strong>Note that binary search only works on sorted arrays</strong>. Make sure to return the
location of the found object (or <code class="sc-cMljjf hbDMZX">nil</code> if not found!). Hint: you will probably
want to use subarrays.</p><p>Make sure that these test cases are working:</p><pre style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"><code style="color: rgb(248, 248, 242); background: none; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; font-size: 16px;">bsearch<span class="token" style="color: rgb(248, 248, 242);">(</span><span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">2</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">3</span><span class="token" style="color: rgb(248, 248, 242);">]</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">)</span> <span class="token" style="color: rgb(119, 128, 144);"># =&gt; 0</span>
bsearch<span class="token" style="color: rgb(248, 248, 242);">(</span><span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">2</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">3</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">4</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">5</span><span class="token" style="color: rgb(248, 248, 242);">]</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">3</span><span class="token" style="color: rgb(248, 248, 242);">)</span> <span class="token" style="color: rgb(119, 128, 144);"># =&gt; 1</span>
bsearch<span class="token" style="color: rgb(248, 248, 242);">(</span><span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">2</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">4</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">6</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">8</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">10</span><span class="token" style="color: rgb(248, 248, 242);">]</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">6</span><span class="token" style="color: rgb(248, 248, 242);">)</span> <span class="token" style="color: rgb(119, 128, 144);"># =&gt; 2</span>
bsearch<span class="token" style="color: rgb(248, 248, 242);">(</span><span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">3</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">4</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">5</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">9</span><span class="token" style="color: rgb(248, 248, 242);">]</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">5</span><span class="token" style="color: rgb(248, 248, 242);">)</span> <span class="token" style="color: rgb(119, 128, 144);"># =&gt; 3</span>
bsearch<span class="token" style="color: rgb(248, 248, 242);">(</span><span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">2</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">3</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">4</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">5</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">6</span><span class="token" style="color: rgb(248, 248, 242);">]</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">6</span><span class="token" style="color: rgb(248, 248, 242);">)</span> <span class="token" style="color: rgb(119, 128, 144);"># =&gt; 5</span>
bsearch<span class="token" style="color: rgb(248, 248, 242);">(</span><span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">2</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">3</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">4</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">5</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">6</span><span class="token" style="color: rgb(248, 248, 242);">]</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">0</span><span class="token" style="color: rgb(248, 248, 242);">)</span> <span class="token" style="color: rgb(119, 128, 144);"># =&gt; nil</span>
bsearch<span class="token" style="color: rgb(248, 248, 242);">(</span><span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">2</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">3</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">4</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">5</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">7</span><span class="token" style="color: rgb(248, 248, 242);">]</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">6</span><span class="token" style="color: rgb(248, 248, 242);">)</span> <span class="token" style="color: rgb(119, 128, 144);"># =&gt; nil</span></code></pre><h3>Merge Sort</h3><p>Implement a method <a href="http://en.wikipedia.org/wiki/Merge_sort" target="_blank"><code class="sc-cMljjf hbDMZX">merge_sort</code></a> that sorts an <code class="sc-cMljjf hbDMZX">Array</code>:</p><ul><li>The base cases are for arrays of length zero or one. Do not use a length-two
array as a base case. This is unnecessary.</li><li>You'll want to write a <code class="sc-cMljjf hbDMZX">merge</code> helper method to merge the sorted halves.</li><li>To get a visual idea of how merge sort works, watch <a href="https://en.wikipedia.org/wiki/Merge_sort#/media/File:Merge-sort-example-300px.gif" target="_blank">this gif</a>
and check out <a href="https://assets.aaonline.io/fullstack/ruby/assets/merge-sort-diagram.png" target="_blank">this diagram</a>.</li></ul><h3>Array Subsets</h3><p>Write a method <code class="sc-cMljjf hbDMZX">subsets</code> that will return all subsets of an array.</p><pre style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"><code style="color: rgb(248, 248, 242); background: none; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; font-size: 16px;">subsets<span class="token" style="color: rgb(248, 248, 242);">(</span><span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(248, 248, 242);">]</span><span class="token" style="color: rgb(248, 248, 242);">)</span> <span class="token" style="color: rgb(119, 128, 144);"># =&gt; [[]]</span>
subsets<span class="token" style="color: rgb(248, 248, 242);">(</span><span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">]</span><span class="token" style="color: rgb(248, 248, 242);">)</span> <span class="token" style="color: rgb(119, 128, 144);"># =&gt; [[], [1]]</span>
subsets<span class="token" style="color: rgb(248, 248, 242);">(</span><span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">2</span><span class="token" style="color: rgb(248, 248, 242);">]</span><span class="token" style="color: rgb(248, 248, 242);">)</span> <span class="token" style="color: rgb(119, 128, 144);"># =&gt; [[], [1], [2], [1, 2]]</span>
subsets<span class="token" style="color: rgb(248, 248, 242);">(</span><span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">2</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">3</span><span class="token" style="color: rgb(248, 248, 242);">]</span><span class="token" style="color: rgb(248, 248, 242);">)</span>
<span class="token" style="color: rgb(119, 128, 144);"># =&gt; [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]</span></code></pre><p>You can implement this as an Array method if you prefer.</p><p><strong>Hint</strong>: For <code class="sc-cMljjf hbDMZX">subsets([1, 2, 3])</code>, there are two kinds of subsets:</p><ul><li>Those that do not contain <code class="sc-cMljjf hbDMZX">3</code> (all of these are subsets of <code class="sc-cMljjf hbDMZX">[1, 2]</code>).</li><li>For every subset that does not contain <code class="sc-cMljjf hbDMZX">3</code>, there is also a corresponding
subset that is the same, except it also <strong>does</strong> contain <code class="sc-cMljjf hbDMZX">3</code>.</li></ul><h3>Permutations</h3><p>Write a recursive method <code class="sc-cMljjf hbDMZX">permutations(array)</code> that calculates all the
<a href="https://en.wikipedia.org/wiki/Permutation" target="_blank">permutations</a> of the given array. For an array of length <code class="sc-cMljjf hbDMZX">n</code>
there are <code class="sc-cMljjf hbDMZX">n!</code> different permutations. So for an array with three elements we
will have <code class="sc-cMljjf hbDMZX">3 * 2 * 1 = 6</code> different permutations.</p><pre style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"><code style="color: rgb(248, 248, 242); background: none; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; font-size: 16px;">permutations<span class="token" style="color: rgb(248, 248, 242);">(</span><span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">2</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">3</span><span class="token" style="color: rgb(248, 248, 242);">]</span><span class="token" style="color: rgb(248, 248, 242);">)</span> <span class="token" style="color: rgb(119, 128, 144);"># =&gt; [[1, 2, 3], [1, 3, 2],</span>
                        <span class="token" style="color: rgb(119, 128, 144);">#     [2, 1, 3], [2, 3, 1],</span>
                        <span class="token" style="color: rgb(119, 128, 144);">#     [3, 1, 2], [3, 2, 1]]</span></code></pre><p>You can use Ruby's built in <a href="https://ruby-doc.org/core-2.2.0/Array.html#method-i-permutation" target="_blank"><code class="sc-cMljjf hbDMZX">Array#permutation</code></a> method to
get a better understanding of what you will be building.</p><pre style="color: rgb(248, 248, 242); background: rgb(45, 45, 45); font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; padding: 1em; overflow: auto; font-size: 16px;"><code style="color: rgb(248, 248, 242); background: none; font-family: Consolas, Monaco, &quot;Andale Mono&quot;, &quot;Ubuntu Mono&quot;, monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; overflow-wrap: normal; line-height: 1.5; tab-size: 4; hyphens: none; font-size: 16px;"><span class="token" style="color: rgb(248, 248, 242);">[</span><span class="token" style="color: rgb(174, 129, 255);">1</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">2</span><span class="token" style="color: rgb(248, 248, 242);">,</span> <span class="token" style="color: rgb(174, 129, 255);">3</span><span class="token" style="color: rgb(248, 248, 242);">]</span><span class="token" style="color: rgb(248, 248, 242);">.</span>permutation<span class="token" style="color: rgb(248, 248, 242);">.</span>to_a  <span class="token" style="color: rgb(119, 128, 144);"># =&gt; [[1, 2, 3], [1, 3, 2],</span>
                            <span class="token" style="color: rgb(119, 128, 144);">#     [2, 1, 3], [2, 3, 1],</span>
                            <span class="token" style="color: rgb(119, 128, 144);">#     [3, 1, 2], [3, 2, 1]]</span></code></pre><h3>Make Change</h3><p>RubyQuiz: <a href="http://web.archive.org/web/20130215052843/http://rubyquiz.com/quiz154.html" target="_blank">Make change</a>.</p><p>Here's a game plan for solving the problem:</p><p>First, write a 'greedy' version called <code class="sc-cMljjf hbDMZX">greedy_make_change</code>:</p><ul><li>Take as many of the biggest coin as possible and add them to your result.</li><li>Add to the result by recursively calling your method on the remaining amount,
leaving out the biggest coin, until the remainder is zero.</li></ul><p>Once you have a working greedy version, talk with your partner about refactoring
this to <code class="sc-cMljjf hbDMZX">make_better_change</code>. What's wrong with <code class="sc-cMljjf hbDMZX">greedy_make_change</code>?</p><p>Consider the case of <code class="sc-cMljjf hbDMZX">greedy_make_change(24, [10,7,1])</code>. Because it takes as
many <code class="sc-cMljjf hbDMZX">10</code> pieces as possible, <code class="sc-cMljjf hbDMZX">greedy_make_change</code> misses the correct answer of
<code class="sc-cMljjf hbDMZX">[10,7,7]</code> (try it in pry).</p><p>To <code class="sc-cMljjf hbDMZX">make_better_change</code>, we only take one coin at a time and never rule out
denominations that we've already used. This allows each coin to be available
each time we get a new remainder. By iterating over the denominations and
continuing to search for the best change, we assure that we test for
'non-greedy' uses of each denomination.</p><p>Discuss the following game plan and then work together to implement your new
method:</p><ul><li>Iterate over each coin.</li><li><strong>Grab only one</strong> of that one coin and recursively call <code class="sc-cMljjf hbDMZX">make_better_change</code>
on the remainder using coins less than or equal to the current coin.</li><li>Add the single coin to the change returned by the recursive call. This
will be a possible solution, but maybe not the best one.</li><li>Keep track of the best solution and return it at the end.</li></ul><p><strong>N.B.</strong> Don't generate every possible permutation of coins and then compare
them. Remember that a permutation is not the same thing as a combination - we
<em>will</em> need to check every combination of coins that add up to our <code class="sc-cMljjf hbDMZX">target</code>, we
just don't want to check the same combination in different orders. If you get
stuck you can start by writing a solution that calculates and compares all of
the permutations without storing them in an array. Then go back and refactor
your solution so that it only calculates and compares all of the different
combinations. If you and your partner get totally stuck, or would like to
compare your answer, feel free to reference <a href="https://vimeo.com/91207646" target="_blank">this video
walkthrough</a> of the problem.</p><p>Make sure you and your partner understand each line before moving on.</p><h2>Resources</h2><ul><li><a href="http://en.wikipedia.org/wiki/Recursion_(computer_science)" target="_blank">Wikipedia: Recursion</a></li></ul></section>
